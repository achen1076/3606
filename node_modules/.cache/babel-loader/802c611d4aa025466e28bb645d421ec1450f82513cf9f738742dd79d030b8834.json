{"ast":null,"code":"// Simple secure authentication service\n// In a production environment, this would connect to a backend API\n\n// In a real app, this would be handled by a backend\n// This is just for demonstration purposes\nconst MOCK_USERS = {\n  'admin': {\n    password: 'kingdom3606',\n    // In real app, passwords would be hashed and stored securely\n    user: {\n      id: '1',\n      username: 'admin',\n      role: 'admin',\n      displayName: 'Kingdom Admin'\n    }\n  },\n  'member': {\n    password: 'member3606',\n    user: {\n      id: '2',\n      username: 'member',\n      role: 'member',\n      displayName: 'Kingdom Member'\n    }\n  }\n};\n\n// Token storage key\nconst TOKEN_KEY = 'kingdom_3606_auth_token';\nconst USER_KEY = 'kingdom_3606_user';\n\n// Simulated token generation\nconst generateToken = user => {\n  // In a real app, this would be a JWT token\n  return btoa(JSON.stringify({\n    userId: user.id,\n    username: user.username,\n    role: user.role,\n    exp: Date.now() + 24 * 60 * 60 * 1000 // 24 hours expiration\n  }));\n};\nexport const login = async (username, password) => {\n  // Simulate network request\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const userRecord = MOCK_USERS[username.toLowerCase()];\n      if (!userRecord || userRecord.password !== password) {\n        reject(new Error('Invalid username or password'));\n        return;\n      }\n      const token = generateToken(userRecord.user);\n      localStorage.setItem(TOKEN_KEY, token);\n      localStorage.setItem(USER_KEY, JSON.stringify(userRecord.user));\n      resolve(userRecord.user);\n    }, 800); // Simulate network delay\n  });\n};\nexport const logout = () => {\n  localStorage.removeItem(TOKEN_KEY);\n  localStorage.removeItem(USER_KEY);\n};\nexport const getCurrentUser = () => {\n  const userJson = localStorage.getItem(USER_KEY);\n  if (!userJson) return null;\n  try {\n    return JSON.parse(userJson);\n  } catch {\n    return null;\n  }\n};\nexport const isAuthenticated = () => {\n  const token = localStorage.getItem(TOKEN_KEY);\n  if (!token) return false;\n  try {\n    const decoded = JSON.parse(atob(token));\n    // Check if token is expired\n    return decoded.exp > Date.now();\n  } catch {\n    return false;\n  }\n};\nexport const getToken = () => {\n  return localStorage.getItem(TOKEN_KEY);\n};","map":{"version":3,"names":["MOCK_USERS","password","user","id","username","role","displayName","TOKEN_KEY","USER_KEY","generateToken","btoa","JSON","stringify","userId","exp","Date","now","login","Promise","resolve","reject","setTimeout","userRecord","toLowerCase","Error","token","localStorage","setItem","logout","removeItem","getCurrentUser","userJson","getItem","parse","isAuthenticated","decoded","atob","getToken"],"sources":["/Users/achen1076/Desktop/3606/src/services/authService.ts"],"sourcesContent":["// Simple secure authentication service\n// In a production environment, this would connect to a backend API\n\ninterface User {\n  id: string;\n  username: string;\n  role: 'admin' | 'member';\n  displayName: string;\n}\n\n// In a real app, this would be handled by a backend\n// This is just for demonstration purposes\nconst MOCK_USERS: Record<string, { password: string; user: User }> = {\n  'admin': {\n    password: 'kingdom3606', // In real app, passwords would be hashed and stored securely\n    user: {\n      id: '1',\n      username: 'admin',\n      role: 'admin',\n      displayName: 'Kingdom Admin'\n    }\n  },\n  'member': {\n    password: 'member3606',\n    user: {\n      id: '2',\n      username: 'member',\n      role: 'member',\n      displayName: 'Kingdom Member'\n    }\n  }\n};\n\n// Token storage key\nconst TOKEN_KEY = 'kingdom_3606_auth_token';\nconst USER_KEY = 'kingdom_3606_user';\n\n// Simulated token generation\nconst generateToken = (user: User): string => {\n  // In a real app, this would be a JWT token\n  return btoa(JSON.stringify({\n    userId: user.id,\n    username: user.username,\n    role: user.role,\n    exp: Date.now() + (24 * 60 * 60 * 1000) // 24 hours expiration\n  }));\n};\n\nexport const login = async (username: string, password: string): Promise<User> => {\n  // Simulate network request\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const userRecord = MOCK_USERS[username.toLowerCase()];\n      \n      if (!userRecord || userRecord.password !== password) {\n        reject(new Error('Invalid username or password'));\n        return;\n      }\n      \n      const token = generateToken(userRecord.user);\n      localStorage.setItem(TOKEN_KEY, token);\n      localStorage.setItem(USER_KEY, JSON.stringify(userRecord.user));\n      \n      resolve(userRecord.user);\n    }, 800); // Simulate network delay\n  });\n};\n\nexport const logout = (): void => {\n  localStorage.removeItem(TOKEN_KEY);\n  localStorage.removeItem(USER_KEY);\n};\n\nexport const getCurrentUser = (): User | null => {\n  const userJson = localStorage.getItem(USER_KEY);\n  if (!userJson) return null;\n  \n  try {\n    return JSON.parse(userJson) as User;\n  } catch {\n    return null;\n  }\n};\n\nexport const isAuthenticated = (): boolean => {\n  const token = localStorage.getItem(TOKEN_KEY);\n  if (!token) return false;\n  \n  try {\n    const decoded = JSON.parse(atob(token));\n    // Check if token is expired\n    return decoded.exp > Date.now();\n  } catch {\n    return false;\n  }\n};\n\nexport const getToken = (): string | null => {\n  return localStorage.getItem(TOKEN_KEY);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}